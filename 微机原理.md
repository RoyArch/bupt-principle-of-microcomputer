# 微机原理

## 8086架构

### 整体结构

![1649019554605](C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649019554605.png)

**总线接口单元BIU：Bus Interface Unit**

- 段寄存器CS DS SS ES
- IP指令指针寄存器
- 地址加法器
- 总线控制器
- 指令队列FIFO
- 功能：执行所有总线操作；运算得到20位物理地址；预取指令，队列长6字节，闲2个就取指令

**执行单元EU：Execute Unit**

- 8通用寄存器：AX BX CX DX SP BP DI SI 通用寄存器可以自行使用
- ALU
- 指令操作控制电路
- 状态标志寄存器
- 功能：指令译码；指令执行；暂存结果；保存标志

 指令预取队列的存在使EU和BIU两个部分可同时进行工作 提高了CPU效率，降低对存储器的要求

**寄存器**

14个 每个16bit：8通用 4段寄存器 2控制寄存器

通用：

数据寄存器AX BX CX DX 地址指针寄存器SP BP 变址寄存器SI DI

- AX：accumulator 

- BX：base address 

- CX：counter 

- DX：data     

	- 高八位AH 低八位AL样式

- SP：stack pointer指向堆栈偏移地址  

- BP：base pointer数据在堆栈段中的基地址

- SI：source index源数据地址，可自动增减 

- DI：destination index存放目的数据地址，可自动增减

段寄存器：

- CS：code segment   

- DS：data segment   

- ES：extra segment   

- SS：stack segment
  - 存放相应逻辑段基地址 只有CS不能软件设置

标志寄存器：

- IP：instruction pointer下一条要执行指令的偏移地址 与CS联合确定指令地址

- Flag

  <img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649020866939.png" alt="1649020866939" style="zoom:50%;float:left;" />

   <img src="https://img-blog.csdnimg.cn/20190830001628834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwOTAxMg==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" /> 

  有符号数用OF判断溢出，无符号数用CF判断溢出

  <img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649022277875.png" alt="1649022277875" style="zoom:50%;float:left;" />

  不难发现，CF=M XOR Cn    OF=Cn-1 XOR Cn（还是逻辑表达式简单明了）

**存储方式**

- 地址线20条 即20bit地址

- 寻址空间2^20=1MB

- 物理地址范围00000H~FFFFFH（还是喜欢前面加0x的表示方式好不好）

- 小段方式，低字节存入低地址，高字节存入高地址

  <img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649022631056.png" alt="1649022631056" style="zoom:50%;float:left" />

**逻辑地址**

​	通过存储器分段（segment）解决16bit->20bit扩展地址问题

​	段基址必须为16的倍数，最大64KB（0H~FFFFH）最小16B（0H~1H）

​	段基址表示为：xxxx0H（注意这个0） xxxxH中的16bit放在段寄存器中

​	逻辑地址表示为：段基址:偏移地址 如6000：0002

​	20bit物理地址=段基址\*16+偏移地址（段地址增加1表示了16B长度，\*16就是左移四位）

​	

## 指令系统与寻址方式

### 指令基本概念

指令集架构ISA（Instruction Set Architecture）包含：寄存器组织，存储器组织，指令集

CISC：通用寄存器少，寻址方式多，复杂指令集，变长指令

RISC：简化指令集，定长指令，寻址方式少，可用寄存器多

指令构成：操作码 0-3个操作数（CISC常见1or2个操作数）

### 寻址方式

**存储器寻址的概念**

​	考虑以下三点

​	存储器寻址都会自动加上段寄存器里面的段基址

1. **有效地址**

   物理地址=段基址+偏移地址 

   偏移地址也成为有效地址effective address EA

   EA=基址（BX、BP）+（变址（SI、DI）*比例因子）+位移量 

   乘比例因子只在386+里面用到，不用管

2. **默认段选择规则**

   <img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649023983846.png" alt="1649023983846" style="zoom:50%;float:left" />

   取决于指令、寻址方式、涉及的寄存器

3. **段超越前缀**

   `mov ax,ds:[bp]` 通过这样的形式否认默认段选择而手动选择段寄存器

   <img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649025300176.png" alt="1649025300176" style="zoom: 67%;float:left" />

**寻址方式一览**

1. **立即寻址**

   操作数使用立即数，不能使用段寄存器

   ```assembly
   MOV AX,55AAH
   ```

2. **寄存器寻址**

   操作数在寄存器里， 源和目的不能同时为段寄存器，目的不能为IP或CS寄存器 （指令地址）

   ```assembly
   MOX AX,BX
   ```

3. **直接寻址**

   ```assembly
   MOV AX,[2000H]
   ```

   出现方括号表示里面写的是地址，且仅包含有效地址EA

4. **寄存器间接寻址**

   ```assembly
   MOV CX,[BX]
   ```

   显而易见从寄存器里读地址，这里用的寄存器使用BX BP SI DI即基址寄存器和变址寄存器

5. **寄存器相对寻址**

   MOV AX,TABLE[BX]或MOV AX,[BX+TABLE]

   table是立即数，对寄存器和位移量求和寻址

6. **基址变址寻址**

   基址寄存器和变址寄存器一起用，两个加起来

   `MOV[BX][SI]`或`MOV[BX+SI]`

7. **相对基址变址寻址**

    `MOV AX,ARRAY[BX][SI]` 或`MOV AX,[BX+SI+ARRAY]`

   三个加起来

8. **后面的其实都是前面操作的变形，不赘述**

**指令地址的转移寻址**

​	**下一条**指令的地址=CS*16+IP

​	顺序执行时IP自动加指令长度，CS不变

​	转移指令时修改IP or CS内容

​	段内转移只修改IP，段间转移修改IP and CS

1. 段内直接转移

   ```assembly
   JMP SHORT NEXT
   JMP NEAR PTR NEXT
   ```
   

short8位相对转移，near ptr16位  next是段内偏移

2. 段内间接转移

   ```assembly
   JMP WORD PTR [BX]
   ```

   WORD 字

3. 段间直接转移

   ```assembly
   JMP FAR PTR ROUTE
   ```

4. 段间间接转移

   ```assembly
   JMP DWORD PTR [BX]
   ```

这段并没讲明白为什么是字 双字这样的 ***完全没明白*** 

但是JMP可以直接跳转，不需要指定操作符，JMP 标号 即可，系统自动修改CS和IP

### 指令格式

<img src="C:\Users\RoyDi\AppData\Roaming\Typora\typora-user-images\1649026194875.png" alt="1649026194875" style="zoom: 67%;float:left" />

指令格式略

1. **数据传送指令**

  1. 通用数据传送指令

     ```assembly
     MOV A,B
     PUSH SRC ;压栈 SP<-SP-2 (SP+1,SP)<-SRC
     POP DST ;出栈DST<-(SP+1,SP) SP<-SP+2 
     ;PUSH加A依次入栈AX CX DX BX SP BP SI DI 加F标志寄存器入栈，POP把顺序反过来
     ;SP被初始化为堆栈大小，每次入栈SP减小，SP=0的时候满了
     XCHG opr1,opr2 ;交换两个数
     ```

  2. 累加器专用传送指令

     ```assembly
     IN AL,port   
     OUT port,AL ;（操作AX的低字节AL）
     IN AX,port   
     OUT port,AX ;（操作（port+1,port）两个字节）
     ```

     ​	port是输入输出设备映射的端口，如果采用以上形式，端口地址**必须是8位的**

     ​	如果端口地址大于8位，**必须放在DX寄存器里**，用DX寻址port

     ```assembly
     XLAT ;AL<-BX+AL
     ```

     ​	BX指向代码表首地址，AL中保存代码表中字符序号，执行后，AL取得对应的码值（表项内容）
     
     ​	看起来没啥大用       
     
  3. 地址传送指令

     ```assembly
     LEA reg,src  ;src使用存储器寻址，将src的有效地址送入reg
     LDS reg,src  ;reg<-src ds<-src+2
     LES reg,src  ;reg<-src ds<-src+2
     ```

  4. 标志寄存器传送指令

     ```assembly
     LAHF ;AH<-flags low byte (load AH form flags)
     SAHF ;flags low byte<-AH (save AH to flags)
     PUSHF ;sp<-sp-2 (sp+1,sp)<-flags (push flags)
     POPF  ;flags<-(sp+1,sp) sp<-sp+2
     ```

  5. 类型转换指令

     ```assembly
     CBW ;AL符号位扩展到AH，字节转换成字
     CWD ;AX符号位扩展到DX，转换成DX:AX中的双字
     ```

2. **算术运算指令**

   1. 加法指令

      ```assembly
      ADD dst,src;add src to dst
      ADC dst,src;add with carry dst<-dst+src+CF
      INC opr;opr+1 不影响CF标志
      XADD dst,src;交换并相加到dst src只能用reg寻址
      ```

      CF对无符号数 最高位进位位1不进位为0 OF对有符号数 两数符号相同并和结果不同为1否则为0

   2. 减法指令

      ```assembly
      SUB dst,src;dst<-dst-src
      SBB dst,src;dst<-dst-src-CF
      CMP dst,src;dst-src只设置flags
      DEC opr;opr-1 不影响cf
      NEG opr;negate 正负变换 只有操作数为0时CF为0否则为1 只有操作数为最小负数OF为1否则为0
      ```

      CF对符号数有借位为1否则为0 OF对有符号数两操作数符号相反结果和减数相同为1否则为0

      还不如记表达式

   3. 乘法指令

   4. 除法指令

   5. 十进制调整指令

1. **逻辑运算指令**
2. **串处理指令**
3. **控制转移指令**
4. **处理机控制指令**

### 指令系统
```

```
